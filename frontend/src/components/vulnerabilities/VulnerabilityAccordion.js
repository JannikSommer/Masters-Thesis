// bootstrap
import Accordion from 'react-bootstrap/Accordion';
import Tab from "react-bootstrap/Tab";
import Tabs from "react-bootstrap/Tabs"
import Row from 'react-bootstrap/Row';
import Col from 'react-bootstrap/Col';
import Button from 'react-bootstrap/Button';
import VulnerabilityDetails from './VulnerabilityDetails';
import Spinner from 'react-bootstrap/esm/Spinner';

import { useRef, useState } from 'react';
import { Buffer } from 'buffer';
import SecurityAdvisory from "../../models/advisory/SecurityAdvisory";
import RSA from '../../cryptography/RSA';
import AES from '../../cryptography/AES';
import Utilities from '../../cryptography/Utilities';
import Web3 from 'web3';

import VulnerabilityAccordionHeader from './VulnerabilityAccordionHeader';
import PrivateVulnerabilityDetails from './PrivateVulnerabilityDetails';
import AdvisoryLoadErrorModal from './AdvisoryLoadErrorModal';

function VulnerabilityAccordion({ vulnerabilities, whitelist, dependencies, privateWhitelist, ipfs }) {
    const loadedAdvisories = useRef([{cid: "", advisory: {}}]);
    const [selectedVulnerabilities, setSelectedVulnerabilities] = useState([]);

    const [loading, setLoading] = useState(true);
    const startLoading = () => setLoading(true); 
    const stopLoading = () => setLoading(false);

    const [showError, setShowError] = useState(false);
    const dismissError = () => setShowError(false);

    /**
     * Function used to select and download the advisories for the selected vulnerability.
     * @param {Object[]} vulnerabilities 
     */
    async function selectVulnerabilities(vulnerabilities) {
        let updatedVulnerabilities = [];
        for await (let vulnerability of vulnerabilities) {
            if (!loadedAdvisories.current.some(entry => entry.cid === vulnerability.cid)) {
                let advisory;
                if (vulnerability.type !== "private") 
                    advisory =  await downloadAdvisory(vulnerability.cid)
                else {
                    try {
                        advisory = await downloadAdvisory(vulnerability.cid, 
                            vulnerability.event.returnValues.decryptionKey, 
                            vulnerability.event.returnValues.iv,
                            vulnerability.tx.to,
                            vulnerability.event.returnValues.hash);
                    }
                    catch (error) {
                        setShowError(true);
                        // close accordion
                        return;
                    }
                }
                loadedAdvisories.current.push({
                    cid: vulnerability.cid, 
                    advisory: advisory
                });
            }
            vulnerability.advisory = loadedAdvisories.current.find(entry => entry.cid === vulnerability.cid).advisory;
            updatedVulnerabilities.push(vulnerability); 
        }
        setSelectedVulnerabilities([...updatedVulnerabilities]);
        stopLoading();
    }

    /**
     * Determines which storage system to use to download the advisory.
     * @param {string} path to the advisory from announcement event. 
     * @returns SecurityAdvisory object parsed from the advisory.
     */
    async function downloadAdvisory(path, decryptionKey = null, iv = null, address = null, hash = null) {
        const storageSystem = path.split("/")[0];
        switch (storageSystem) {
            case "ipfs":
                if (decryptionKey === null)
                    return await loadIpfsContent(path.split("/")[1]);
                else 
                    return await loadEncryptedIpfsContent(path.split("/")[1], decryptionKey, iv, address, hash);
            case "arweave":
                throw new Error("Arweave not yet supported.");
            case "swarm": 
                throw new Error("Swarm not yet supported.");
            default:
                if (decryptionKey === null)
                    return await loadIpfsContent(path);
                else 
                    return await loadEncryptedIpfsContent(path, decryptionKey, iv, address, hash);        
        }
    }

    /**
     * Download an advisory from IPFS.
     * @param {string} cid IPFS Content Identifier of the advisory.
     * @returns Parsed advisory.
     */
    async function loadIpfsContent(cid) {
        let content = [];
        for await (const chunk of await ipfs.cat(cid)) {
            content = [...content, ...chunk];
        }
        return new SecurityAdvisory(Buffer.from(content).toString('utf8'));
    }

    /**
     * Computes the hash of a content string and returns it as a HEX string.
     * @param {string} content 
     * @returns {string}
     */
    async function computeContentHash(content) {
        const contentBytes = Utilities.stringToArrayBuffer(content);
        const contentDigest = await window.crypto.subtle.digest("SHA-256", contentBytes);
        return Web3.utils.bytesToHex(new Uint8Array(contentDigest));
    }

    /**
     * Download an encrypted advisory from IPFS.
     * @param {string} cid IPFS Content Identifier of the advisory.
     * @returns Parsed advisory.
     */
    async function loadEncryptedIpfsContent(cid, decryptionKey, iv, vendor, hash) {
        try {
            let privateKey = privateWhitelist.find(entry => entry.address === vendor).privateKey;
            let content = [];
            for await (const chunk of await ipfs.cat(cid)) {
                content = [...content, ...chunk];
            }
            const rsa = new RSA(); 
            const importKey = await rsa.importPrivateKey(Utilities.base64ToArrayBuffer(privateKey));
            const key = await rsa.unwrapKey(new Uint8Array(Web3.utils.hexToBytes(decryptionKey)), importKey);
    
            const aes = new AES(128);
            const decryptedContent = await aes.decrypt(Buffer.from(content), key, new Uint8Array(Web3.utils.hexToBytes(iv)));
            
            const contentHash = computeContentHash(decryptedContent);

            console.log(hash + "===" + contentHash);
            if(hash !== contentHash) throw Error("Downloaded hash does not match computed hash")

            return new SecurityAdvisory(decryptedContent.toString('utf8'));
        }
        catch (error) {
            throw error;
        }
    }

    /**
     * Downloads the advisory as a CSAF file to the users computer.
     * @param {SecurityAdvisory} advisory 
     */
    const download = (advisory) => {
        const element = document.createElement("a");
        const file = new Blob([JSON.stringify(advisory)], {type: 'application/json'});
        element.href = URL.createObjectURL(file);
        element.download = advisory.title + ".json";
        document.body.appendChild(element);
        element.click();
    }

    return (
        <>
        <AdvisoryLoadErrorModal show={showError} dismiss={dismissError} />
        <Accordion>
            {vulnerabilities.map((vulnerability, index) =>
                <Accordion.Item key={index} eventKey={index}>
                    <VulnerabilityAccordionHeader 
                        vulnerability={vulnerability}
                        publicWhitelist={whitelist}
                        privateWhitelist={privateWhitelist}
                    />
                    <Accordion.Body onEnter={() => {startLoading(); selectVulnerabilities(vulnerability)}}>
                        {loading === false 
                            ?   <div><p>Use the tabs below to select a specific version of the advisory to get information from.</p>
                                    <Tabs>
                                        {selectedVulnerabilities.map((version, index) => 
                                            <Tab key={index} eventKey={"VulnerabilityDetails" + index} 
                                                title={"version " + index}>
                                                <br></br>
                                                <Row>
                                                    <Col lg="10">
                                                        <h2>{version.advisory.title}</h2>
                                                    </Col>
                                                    <Col lg="2">
                                                        <Button onClick={() => download(version.advisory)}>Download CSAF</Button>
                                                    </Col>
                                                </Row>
                                                <hr></hr>
                                                <h3>{version.advisory.description}</h3>
                                                <br />
                                                {version.type === "private"
                                                    ? <PrivateVulnerabilityDetails advisory={version.advisory} />
                                                    : dependencies !== []
                                                        ? <VulnerabilityDetails
                                                            advisory={version.advisory} 
                                                            dependencies={dependencies}
                                                            vulnerabilityIds={version.event.returnValues.vulnerabilityIdentifiers.split(",")}
                                                          />
                                                        : <h5>Cannot show because of missing dependency information.</h5>
                                                }
                                            </Tab>
                                        )}
                                    </Tabs>
                                </div>
                            :   <Spinner animation="border" role="status"  style={{ width: "4rem", height: "4rem" }}>
                                    <span className="visually-hidden">Loading...</span>
                                </Spinner>
                        }
                    </Accordion.Body>
                </Accordion.Item>
            )}
        </Accordion>
        </>
    )
}
export default VulnerabilityAccordion;