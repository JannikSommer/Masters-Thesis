import Status from "./Status";
import RemediationStrategy from "./RemediationStrategy";
/**
 * Represents a vulnerability from a CSAF document.
 */
export default class Vulnerability {
    /**
     * An array of strings describing the vulnerability.
     * @type {String[]}
     */
    description;

    /**
     * The remediation strategies for the vulnerability.
     * @type {RemediationStrategy[]}
    */
    remediations;
    
    /**
     * The CVSS v3 scores for the affected products.
     * @type {Map<String, Number>}
     */
    cvss;

    /**
     * A Common Weakness Enumeration (CWE) id associated with the vulnerability.
     * @type {String}
     */
    cwe = "";

    /**
     * The affected product ids.
     * @type {Map<String, String>}
     */
    productStatus;

    
    /**
     * Instantiates a Vulnerability object based on a 'vulnerability' from a CSAF document.
     * @param {Object} vulnerabilityObject A parsed 'vulnerability' object from a CSAF document.
     */
    constructor (vulnerabilityObject) {
        this.extractVulnerability(vulnerabilityObject);
    }

    /**
     * Extracts relevant information from a vulnerability object from a CSAF document.
     * @private
     * @param {Object} vulnerability A parsed 'vulnerability' object from a CSAF document.
     */
    extractVulnerability(vulnerability) {
        if(vulnerability["cwe"] && vulnerability["cwe"]["id"]) this.cwe = vulnerability["cwe"]["id"];
        if(vulnerability["scores"]) this.cvss = this.extractCVSS(vulnerability["scores"])
        this.productStatus = this.extractProductStatus(vulnerability["product_status"]);
        this.description = this.extractDescription(vulnerability["notes"]);
        this.remediations = this.extractRemediations(vulnerability["remediations"]);
    }

    /**
     * Extracts the cvss scores of products related to the vulnerability.
     * @private
     * @param {Object[]} scoresArray An array of score objects from a CSAF document.
     * @returns {Map<String, Number>} A map of productId-cvss score key-value pairs.
     */
    extractCVSS(scoresArray) {
        if (!scoresArray && scoresArray["cvss_v3"]) return new Map(); // If no scores are provided.
        
        var scores = new Map();

        scoresArray.forEach(score => {
            score["products"].forEach(productId => {
                scores.set(productId, score["cvss_v3"]["baseScore"]);
            });
        });

        return scores;
    }

    /**
     * Extracts the product statuses in a CSAF document.
     * @private
     * @param {Object} productStatusObject The product_status object in a CSAF document.
     * @returns {Map<String, String>} An object of key-value pairs for retrieving a product status given a productId.
     */
    extractProductStatus(productStatusObject) {
        var productStatuses = new Map();

        if(!productStatusObject) return productStatuses; // If no product_status object was provided in the CSAF doc.

        if(productStatusObject[Status.Fixed]) {
            this.addProductStatuses(productStatuses, productStatusObject[Status.Fixed], Status.Fixed);
        }
        if(productStatusObject[Status.KnownAffected]) {
            this.addProductStatuses(productStatuses, productStatusObject[Status.KnownAffected], Status.KnownAffected);
        }
        if(productStatusObject[Status.KnownNotAffected]) {
            this.addProductStatuses(productStatuses, productStatusObject[Status.KnownNotAffected], Status.KnownNotAffected);
        }
        if(productStatusObject[Status.UnderInvestigation]) {
            this.addProductStatuses(productStatuses, productStatusObject[Status.UnderInvestigation], Status.UnderInvestigation);
        }

        return productStatuses;
    }

    /**
     * Adds a list of 'productId'-'status' key-value pairs to the status lookup.
     * @private
     * @param {Object} productStatuses The dictionary used to look up product statuses.
     * @param {String[]} products The list of product ids to add.
     * @param {String} status The status of the products.
     */
    addProductStatuses(productStatuses, products, status) {
        products.forEach(product => {
            productStatuses.set(product, status);
        })
    }

    /**
     * Extracts details about the vulnerability described in a CSAF document.
     * @private
     * @param {Object[]} notesArray An array of notes from a CSAF document.
     * @returns {String[]} An array of string containing information on the vulnerability.
     */
    extractDescription(notesArray) {
        var desc = [];

        if(!notesArray) { // If no notes are found in the document.
            return desc;
        }

        notesArray.forEach(note => {
            if(note["other"]) { // "other" notes should have title include for additional information.
                desc.push(note["title"] + ": " + note["text"]); 
            } else {
                desc.push(note["text"]);
            }
        });

        return desc;
    }

    /**
     * Extracts the remediation strategies for the vulnerability.
     * @private
     * @param {Object[]} remediationsArray An array of remediations from a CSAF document.
     * @returns {RemediationStrategy[]} An array of remediation strategies.
     */
    extractRemediations(remediationsArray) {
        if(!remediationsArray) { // If no remediations are found in the document.
            return [];
        }

        var remediations = [];
        remediationsArray.forEach(remediation => {
            remediations.push(
                new RemediationStrategy(remediation));
        });

        return remediations;
    }

    /** Retrieves status, cvss, and remediations for a product related to this vulnerability.
     * @param {string} productId A valid product id.
     * @returns {Object | undefined} Return an object containing status, cvss, and remediations. 
     */
    getProductInformation(productId) {
        var result = {};

        if(!this.productStatus.has(productId)) return undefined;
        result.status = this.productStatus.get(productId);
        
        result.cvss = !this.cvss.has(productId) ? "Not provided" : this.cvss.get(productId);
        
        result.remediations = [];
        this.remediations.forEach(remediation => {
            if(remediation.productIds.has(productId)) result.remediations.push(remediation);
        });
        
        return result;
    }
}